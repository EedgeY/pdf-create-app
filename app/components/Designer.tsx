'use client';

import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { checkTemplate, cloneDeep, Lang, Template } from '@pdfme/common';
import { Designer } from '@pdfme/ui';
import { Download, FileText, Save, Sparkles, Upload } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';
import {
  downloadJsonFile,
  generatePDF,
  getFontsData,
  getPlugins,
  getTemplateByPreset,
  getTemplatePresets,
  readFile,
} from '../helper';
import { AITemplateGenerator } from './AITemplateGenerator';
import { FloatingActionButtons } from './FloatingActionButtons';
import MarkdownViewer from './MarkdownViewer';
import { svgToPngDataURL } from '../plugins';
import { useImageStore } from '../store/imageStore';
import ReactCodeEditor from './ReactCodeEditor';

const headerHeight = 80;

const initialTemplatePresetKey = 'invoice';
const customTemplatePresetKey = 'custom';

const templatePresets = getTemplatePresets();

function PDFDesignerApp() {
  const designerRef = useRef<HTMLDivElement | null>(null);
  const designer = useRef<Designer | null>(null);
  const [lang, setLang] = useState<Lang>('en');
  const [templatePreset, setTemplatePreset] = useState<string>(
    initialTemplatePresetKey
  );
  const [prevDesignerRef, setPrevDesignerRef] = useState<HTMLDivElement | null>(
    null
  );
  const [isAIDialogOpen, setIsAIDialogOpen] = useState(false);
  const [isMarkdownDialogOpen, setIsMarkdownDialogOpen] = useState(false);
  const [currentTemplate, setCurrentTemplate] = useState<Template | null>(null);
  const [isReactEditorOpen, setIsReactEditorOpen] = useState(false);

  // Áä∂ÊÖãÁÆ°ÁêÜ„Çπ„Éà„Ç¢„Åã„ÇâÁîªÂÉè„Éá„Éº„Çø„ÇíÂèñÂæó
  const { generatedImage, clearGeneratedImage } = useImageStore();

  useEffect(() => {
    const storedTemplatePreset = localStorage.getItem('templatePreset');
    if (storedTemplatePreset) {
      setTemplatePreset(storedTemplatePreset);
    }
  }, []);

  // SVGÁîªÂÉè„Çí„Éá„Ç∂„Ç§„Éä„Éº„Å´ËøΩÂä†„Åô„ÇãÂá¶ÁêÜ
  useEffect(() => {
    if (generatedImage && designer.current) {
      console.log('ÁîüÊàê„Åï„Çå„ÅüÁîªÂÉè„Çí„Éá„Ç∂„Ç§„Éä„Éº„Å´ËøΩÂä†„Åó„Åæ„Åô');

      try {
        // ÂÖÉ„ÅÆhandleAddElement„Çí„Åì„Åì„ÅßÁõ¥Êé•‰ΩøÁî®„Åõ„Åö„ÄÅÂ∞ë„ÅóÈÅÖÂª∂„Åï„Åõ„Å¶ÂÆüË°å
        setTimeout(() => {
          // „Éá„Ç∂„Ç§„Éä„Éº„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
          if (designer.current) {
            try {
              // „Çπ„Ç≠„Éº„Éû„Å´Âêà„Å£„ÅüË¶ÅÁ¥†„Çí‰ΩúÊàê„Åó„Å¶ËøΩÂä†
              const element = {
                type: 'image', // „Çπ„Ç≠„Éº„Éû„Çø„Ç§„Éó
                content: generatedImage, // ÁîªÂÉè„Ç≥„É≥„ÉÜ„É≥„ÉÑ
                width: 150,
                height: 100,
              };

              handleAddElement(element);
              console.log('Ë¶ÅÁ¥†„ÅåÊ≠£Â∏∏„Å´ËøΩÂä†„Åï„Çå„Åæ„Åó„Åü');
            } catch (innerError) {
              console.error('Ë¶ÅÁ¥†ËøΩÂä†‰∏≠„ÅÆ„Ç®„É©„Éº:', innerError);
            }
          }
        }, 500);

        // ‰ΩøÁî®Âæå„ÅØ„Çπ„Éà„Ç¢„Çí„ÇØ„É™„Ç¢
        clearGeneratedImage();
      } catch (error) {
        console.error('„Éá„Ç∂„Ç§„Éä„Éº„Å´Ë¶ÅÁ¥†„ÇíËøΩÂä†„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü:', error);
      }
    }
  }, [generatedImage]);

  const buildDesigner = () => {
    let template: Template = getTemplateByPreset(
      localStorage.getItem('templatePreset') || ''
    );
    try {
      const templateString = localStorage.getItem('template');
      if (templateString) {
        setTemplatePreset(customTemplatePresetKey);
      }

      const templateJson = templateString
        ? JSON.parse(templateString)
        : getTemplateByPreset(localStorage.getItem('templatePreset') || '');
      checkTemplate(templateJson);
      template = templateJson as Template;
    } catch {
      localStorage.removeItem('template');
    }

    getFontsData().then((font) => {
      if (designerRef.current) {
        designer.current = new Designer({
          domContainer: designerRef.current,
          template,
          options: {
            font,
            lang,
            labels: {
              clear: 'üóëÔ∏è', // Add custom labels to consume them in your own plugins
            },
            theme: {
              token: {
                colorPrimary: '#25c2a0',
              },
            },
            icons: {
              multiVariableText:
                '<svg fill="#000000" width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6.643,13.072,17.414,2.3a1.027,1.027,0,0,1,1.452,0L20.7,4.134a1.027,1.027,0,0,1,0,1.452L9.928,16.357,5,18ZM21,20H3a1,1,0,0,0,0,2H21a1,1,0,0,0,0-2Z"/></svg>',
            },
          },
          plugins: getPlugins(),
        });
        designer.current.onSaveTemplate(onSaveTemplate);
        designer.current.onChangeTemplate(() => {
          setTemplatePreset(customTemplatePresetKey);
        });
      }
    });
  };

  const onChangeBasePDF = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target && e.target.files) {
      readFile(e.target.files[0], 'dataURL').then(async (basePdf) => {
        if (designer.current) {
          designer.current.updateTemplate(
            Object.assign(cloneDeep(designer.current.getTemplate()), {
              basePdf,
            })
          );
        }
      });
    }
  };

  const onChangePadding = () => {
    if (designerRef.current && designer.current) {
      const currentTemplate = designer.current.getTemplate();
      const updatedTemplate = {
        ...currentTemplate,
        options: {
          ...(currentTemplate.options || {}),
          padding: [10, 10, 10, 10],
        },
        schemas: currentTemplate.schemas,
        basePdf: currentTemplate.basePdf,
      };
      designer.current.updateTemplate(updatedTemplate);
    }
  };

  const onDownloadTemplate = () => {
    if (designer.current) {
      downloadJsonFile(designer.current.getTemplate(), 'template');
      console.log(designer.current.getTemplate());
    }
  };

  const onSaveTemplate = (template?: Template) => {
    if (designer.current) {
      localStorage.setItem(
        'template',
        JSON.stringify(template || designer.current.getTemplate())
      );
      alert('‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ');
    }
  };

  const onChangeTemplatePresets = (value: string) => {
    setTemplatePreset(value);
    localStorage.setItem(
      'template',
      JSON.stringify(
        getTemplateByPreset(localStorage.getItem('templatePreset') || '')
      )
    );
    localStorage.removeItem('template');
    localStorage.setItem('templatePreset', value);
    buildDesigner();
  };

  const handleApplyAITemplate = (template: Template) => {
    if (designer.current) {
      designer.current.updateTemplate(template);
      setTemplatePreset(customTemplatePresetKey);
      setIsAIDialogOpen(false);
    }
  };

  // Êñ∞„Åó„ÅÑË¶ÅÁ¥†„ÇíËøΩÂä†„Åô„Çã„Éè„É≥„Éâ„É©
  const handleAddElement = (elementOrElements: any | any[]) => {
    if (designer.current) {
      try {
        const currentTemplate = designer.current.getTemplate();
        const currentSchemas = currentTemplate.schemas;

        // ÁèæÂú®„ÅÆ„Çπ„Ç≠„Éº„Éû„ÅÆÊúÄÂàù„ÅÆ„Éö„Éº„Ç∏„Å´Êñ∞„Åó„ÅÑË¶ÅÁ¥†„ÇíËøΩÂä†
        if (currentSchemas.length > 0) {
          const updatedSchemas = [...currentSchemas];

          // Ë¶ÅÁ¥†„ÅåÈÖçÂàóÔºàË§áÊï∞Ë¶ÅÁ¥†Ôºâ„ÅÆÂ†¥Âêà
          if (Array.isArray(elementOrElements)) {
            updatedSchemas[0] = [...updatedSchemas[0], ...elementOrElements];
            console.log(`${elementOrElements.length}ÂÄã„ÅÆË¶ÅÁ¥†„ÅåËøΩÂä†„Åï„Çå„Åæ„Åó„Åü`);
          } else {
            // Âçò‰∏ÄË¶ÅÁ¥†„ÅÆÂ†¥Âêà
            updatedSchemas[0] = [...updatedSchemas[0], elementOrElements];
            console.log('Ë¶ÅÁ¥†„ÅåËøΩÂä†„Åï„Çå„Åæ„Åó„Åü:', elementOrElements);
          }

          // „ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÊõ¥Êñ∞
          const updatedTemplate = {
            ...currentTemplate,
            schemas: updatedSchemas,
          };

          designer.current.updateTemplate(updatedTemplate);
          setTemplatePreset(customTemplatePresetKey);
        }
      } catch (error) {
        console.error('Ë¶ÅÁ¥†„ÅÆËøΩÂä†‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
        alert('Ë¶ÅÁ¥†„ÅÆËøΩÂä†‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
      }
    }
  };

  // „ÉÜ„Éº„Éñ„É´Ë¶ÅÁ¥†„ÇíËøΩÂä†„Åô„ÇãÈñ¢Êï∞
  const handleAddTable = () => {
    const tableElement = {
      name: 'sample_table',
      type: 'table',
      position: { x: 20, y: 20 },
      width: 160,
      height: 80,
      content: '[[null,null,null],[null,null,null],[null,null,null]]',
      showHead: true,
      head: ['È†ÖÁõÆ', 'Âçò‰æ°', 'Êï∞Èáè'],
      headWidthPercentages: [33.3, 33.3, 33.4],
      fontName: 'NotoSansJP-Regular',
      tableStyles: {
        borderWidth: 1,
        borderColor: '#000000',
      },
      headStyles: {
        fontName: 'NotoSansJP-Regular',
        fontSize: 10,
        alignment: 'center',
        verticalAlignment: 'middle',
        fontColor: '#000000',
        backgroundColor: '#f5f5f5',
        lineHeight: 1.2,
        characterSpacing: 0,
        borderWidth: {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1,
        },
        padding: {
          top: 2,
          right: 2,
          bottom: 2,
          left: 2,
        },
      },
      bodyStyles: {
        fontName: 'NotoSansJP-Regular',
        fontSize: 10,
        alignment: 'left',
        verticalAlignment: 'middle',
        fontColor: '#000000',
        backgroundColor: '#FFFFFF',
        lineHeight: 1.2,
        characterSpacing: 0,
        borderWidth: {
          top: 0,
          right: 1,
          bottom: 1,
          left: 1,
        },
        padding: {
          top: 2,
          right: 2,
          bottom: 2,
          left: 2,
        },
      },
      columnStyles: {
        alignment: {
          '0': 'left',
          '1': 'right',
          '2': 'center',
        },
      },
    };

    handleAddElement(tableElement);
  };

  // „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„Éì„É•„Éº„Ç¢„ÇíÈñã„Åè„Éè„É≥„Éâ„É©
  const handleOpenMarkdownView = () => {
    if (designer.current) {
      const template = designer.current.getTemplate();
      console.log('„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„Éì„É•„Éº„Ç¢„Å´Ê∏°„Åô„ÉÜ„É≥„Éó„É¨„Éº„Éà:', template);
      setCurrentTemplate(template);
      setIsMarkdownDialogOpen(true);
    } else {
      console.error('„Éá„Ç∂„Ç§„Éä„Éº„Åå„Åæ„Å†ÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
    }
  };

  // „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„Åã„ÇâÂ§âÊèõ„Åï„Çå„Åü„ÉÜ„É≥„Éó„É¨„Éº„ÉàË¶ÅÁ¥†„ÇíÈÅ©Áî®„Åô„Çã„Éè„É≥„Éâ„É©
  const handleApplyMarkdownTemplate = (elements: any[]) => {
    try {
      if (designer.current) {
        const currentTemplate = designer.current.getTemplate();
        const currentSchemas = [...currentTemplate.schemas];

        // ÊúÄÂàù„ÅÆ„Éö„Éº„Ç∏„ÅÆ„Çπ„Ç≠„Éº„Éû„ÇíÂèñÂæóÔºàÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàêÔºâ
        if (currentSchemas.length === 0) {
          currentSchemas.push([] as any);
        }

        // Êñ∞„Åó„ÅÑË¶ÅÁ¥†„Çí„Éö„Éº„Ç∏„Å´ËøΩÂä†
        const newElements: Record<string, any> = {};
        elements.forEach((element) => {
          // ‰∏ÄÊÑè„ÅÆID„ÇíÁîüÊàê
          const elementId = `md-${
            element.name || 'element'
          }-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          // Ë¶ÅÁ¥†„ÇíËøΩÂä†
          newElements[elementId] = element;
        });

        // „Çπ„Ç≠„Éº„Éû„ÅÆÊúÄÂàù„ÅÆ„Éö„Éº„Ç∏„ÇíÊõ¥Êñ∞
        if (Array.isArray(currentSchemas[0])) {
          // ÈÖçÂàó„ÅÆÂ†¥Âêà„ÅØÈÖçÂàóÂΩ¢Âºè„Å´Â§âÊèõ„Åó„Å¶‰ª£ÂÖ•
          currentSchemas[0] = Object.values(newElements) as any;
        } else {
          // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà„ÅØÊó¢Â≠ò„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´ËøΩÂä†
          currentSchemas[0] = {
            ...(currentSchemas[0] as any),
            ...newElements,
          } as any;
        }

        // „ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÊõ¥Êñ∞
        const updatedTemplate = {
          ...currentTemplate,
          schemas: currentSchemas,
        };

        designer.current.updateTemplate(updatedTemplate);
        setCurrentTemplate(updatedTemplate);
        setIsMarkdownDialogOpen(false);

        // AI„Çí‰Ωø„Å£„Å¶„É¨„Ç§„Ç¢„Ç¶„Éà„ÇíÊúÄÈÅ©Âåñ
        optimizeLayoutWithAI(updatedTemplate);
      }
    } catch (error) {
      console.error('„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„ÉÜ„É≥„Éó„É¨„Éº„ÉàÈÅ©Áî®„Ç®„É©„Éº:', error);
    }
  };

  // AI„Çí‰Ωø„Å£„Å¶„É¨„Ç§„Ç¢„Ç¶„Éà„ÇíÊúÄÈÅ©Âåñ„Åô„ÇãÈñ¢Êï∞
  const optimizeLayoutWithAI = async (template: Template) => {
    try {
      // ÁèæÂú®„ÅÆ„Åô„Åπ„Å¶„ÅÆË¶ÅÁ¥†„ÇíÂèéÈõÜ
      const allElements: any[] = [];

      template.schemas.forEach((schema) => {
        if (Array.isArray(schema)) {
          schema.forEach((element) => {
            if (element) allElements.push(element);
          });
        } else {
          Object.values(schema).forEach((element) => {
            if (element) allElements.push(element);
          });
        }
      });

      // AI„Å´„Çà„Çã„É¨„Ç§„Ç¢„Ç¶„ÉàÊúÄÈÅ©ÂåñAPI„ÇíÂëº„Å≥Âá∫„Åô
      const response = await fetch('/api/openrouter/generate-layout-edit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          prompt: 'PDF„ÅÆË¶ÅÁ¥†„ÇíÊï¥„Åà„Å¶„ÄÅË™≠„Åø„ÇÑ„Åô„ÅèÁæé„Åó„ÅÑ„É¨„Ç§„Ç¢„Ç¶„Éà„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
          model: 'openai/gpt-3.5-turbo',
          currentElements: allElements,
          pageSize: { width: 210, height: 297 }, // A4„Çµ„Ç§„Ç∫
          layoutOptions: {
            spacing: 'comfortable',
            autoSize: true,
          },
        }),
      });

      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const data = await response.json();
      const optimizedElements = data.optimizedElements || [];

      if (optimizedElements.length > 0 && designer.current) {
        // ÊúÄÈÅ©Âåñ„Åï„Çå„ÅüË¶ÅÁ¥†„Åß„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÊõ¥Êñ∞
        const currentTemplate = designer.current.getTemplate();
        const currentSchemas = [...currentTemplate.schemas];

        // ÊúÄÂàù„ÅÆ„Éö„Éº„Ç∏„ÅÆ„Çπ„Ç≠„Éº„Éû„ÇíÊõ¥Êñ∞
        if (currentSchemas.length === 0) {
          currentSchemas.push([] as any);
        }

        // Êñ∞„Åó„ÅÑ„Çπ„Ç≠„Éº„Éû„Çí‰ΩúÊàê
        const newElements: Record<string, any> = {};

        // ÊúÄÈÅ©Âåñ„Åï„Çå„ÅüË¶ÅÁ¥†„ÇíËøΩÂä†
        optimizedElements.forEach((element: any, index: number) => {
          const elementId = `optimized-${element.name || 'element'}-${index}`;
          newElements[elementId] = element;
        });

        // „Çπ„Ç≠„Éº„Éû„ÇíÊõ¥Êñ∞
        if (Array.isArray(currentSchemas[0])) {
          // ÈÖçÂàó„ÅÆÂ†¥Âêà„ÅØÈÖçÂàóÂΩ¢Âºè„Å´Â§âÊèõ
          currentSchemas[0] = Object.values(newElements) as any;
        } else {
          // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà„ÅØÊñ∞„Åó„ÅÑ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅßÁΩÆ„ÅçÊèõ„Åà
          currentSchemas[0] = newElements as any;
        }

        // „ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÊõ¥Êñ∞
        const updatedTemplate = {
          ...currentTemplate,
          schemas: currentSchemas,
        };

        designer.current.updateTemplate(updatedTemplate);
      }
    } catch (error) {
      console.error('„É¨„Ç§„Ç¢„Ç¶„ÉàÊúÄÈÅ©Âåñ„Ç®„É©„Éº:', error);
    }
  };

  // ReactCodeEditor„ÇíÈñã„Åè„Éè„É≥„Éâ„É©
  const handleOpenReactEditor = () => {
    setIsReactEditorOpen(true);
  };

  const handleReactSvgGenerate = async (svgElement: SVGElement) => {
    try {
      const dataUrl = await svgToPngDataURL(svgElement);
      // ÁîüÊàê„Åï„Çå„ÅüÁîªÂÉè„Éá„Éº„Çø„Çí„ÉÜ„É≥„Éó„É¨„Éº„Éà„Å´ËøΩÂä†
      if (designer.current) {
        const currentTemplate = designer.current.getTemplate();
        const currentSchemas = [...currentTemplate.schemas];

        // ÊúÄÂàù„ÅÆ„Éö„Éº„Ç∏„ÅÆ„Çπ„Ç≠„Éº„Éû„ÇíÂèñÂæóÔºàÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàêÔºâ
        if (currentSchemas.length === 0) {
          currentSchemas.push([] as any);
        }

        // ÁîªÂÉèË¶ÅÁ¥†„ÇíËøΩÂä†
        const imageElement = {
          name: `react-image-${Date.now()}`,
          type: 'image',
          content: dataUrl,
          position: { x: 50, y: 50 },
          width: 150,
          height: 100,
        };

        // ÊúÄÂàù„ÅÆ„Éö„Éº„Ç∏„Å´Ë¶ÅÁ¥†„ÇíËøΩÂä†
        if (Array.isArray(currentSchemas[0])) {
          currentSchemas[0] = [...currentSchemas[0], imageElement];
        } else {
          currentSchemas[0] = [imageElement];
        }

        // „ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÊõ¥Êñ∞
        designer.current.updateTemplate({
          ...currentTemplate,
          schemas: currentSchemas,
        });
      }
      setIsReactEditorOpen(false);
      return dataUrl;
    } catch (error) {
      console.error('SVGÂ§âÊèõ„Ç®„É©„Éº:', error);
      throw error;
    }
  };

  if (designerRef.current !== prevDesignerRef) {
    if (prevDesignerRef && designer.current) {
      designer.current.destroy();
    }
    buildDesigner();
    setPrevDesignerRef(designerRef.current);
  }

  return (
    <div className=' py-6'>
      <div className='mb-6 space-y-4'>
        <div className='flex flex-col sm:flex-row gap-4 justify-between'>
          <div className='flex flex-col gap-3 sm:flex-row sm:items-end'>
            <div className='space-y-2'>
              <Label htmlFor='template-preset' className='text-sm'>
                „ÉÜ„É≥„Éó„É¨„Éº„Éà
              </Label>
              <Select
                value={templatePreset}
                onValueChange={onChangeTemplatePresets}
              >
                <SelectTrigger id='template-preset' className='w-[200px]'>
                  <SelectValue placeholder='„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÈÅ∏Êäû' />
                </SelectTrigger>
                <SelectContent>
                  {Object.keys(templatePresets).map((key) => (
                    <SelectItem key={key} value={key}>
                      {templatePresets[key as any].label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className='space-y-2'>
              <Label htmlFor='pdf-file' className='text-sm'>
                „Éô„Éº„ÇπPDF
              </Label>
              <div className='flex items-center gap-2'>
                <Button
                  variant='outline'
                  size='sm'
                  className='w-[200px] justify-start'
                  onClick={() => document.getElementById('pdf-file')?.click()}
                >
                  <Upload className='h-4 w-4 mr-2' />
                  PDF„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
                </Button>
                <Input
                  id='pdf-file'
                  type='file'
                  className='hidden'
                  accept='application/pdf'
                  onChange={onChangeBasePDF}
                />
              </div>
            </div>
          </div>

          <div className='flex flex-wrap gap-2 items-end justify-end'>
            <Dialog open={isAIDialogOpen} onOpenChange={setIsAIDialogOpen}>
              <DialogTrigger asChild>
                <Button variant='outline' size='sm'>
                  <Sparkles className='h-4 w-4 mr-2' />
                  AI„ÅßÁîüÊàê
                </Button>
              </DialogTrigger>
              <DialogContent className='max-w-3xl'>
                <DialogHeader>
                  <DialogTitle>AI„ÉÜ„É≥„Éó„É¨„Éº„ÉàÁîüÊàê</DialogTitle>
                </DialogHeader>
                <AITemplateGenerator
                  onApplyTemplate={handleApplyAITemplate}
                  currentTemplate={designer.current?.getTemplate()}
                />
              </DialogContent>
            </Dialog>

            <Button
              variant='outline'
              size='sm'
              onClick={() => onSaveTemplate()}
            >
              <Save className='h-4 w-4 mr-2' />
              ‰øùÂ≠ò
            </Button>

            <Button variant='outline' size='sm' onClick={onDownloadTemplate}>
              <Download className='h-4 w-4 mr-2' />
              „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            </Button>

            <Button
              variant='outline'
              size='sm'
              onClick={() => generatePDF(designer.current)}
            >
              <FileText className='h-4 w-4 mr-2' />
              PDFÁîüÊàê
            </Button>

            <Button
              onClick={handleOpenMarkdownView}
              variant='outline'
              className='whitespace-nowrap'
            >
              „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥Ë°®Á§∫
            </Button>

            <Button size='sm' variant='outline' onClick={handleOpenReactEditor}>
              React„Ç®„Éá„Ç£„Çø
            </Button>
          </div>
        </div>
      </div>

      <div
        ref={designerRef}
        style={{
          height: 'calc(100vh - 200px)',
          width: '100%',
        }}
      />

      <FloatingActionButtons
        onApplyElement={handleAddElement}
        designerRef={designerRef}
      />

      {/* „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„Éì„É•„Éº„Ç¢„ÉÄ„Ç§„Ç¢„É≠„Ç∞ */}
      <Dialog
        open={isMarkdownDialogOpen}
        onOpenChange={setIsMarkdownDialogOpen}
      >
        <DialogContent className='max-w-5xl max-h-[80vh] overflow-y-auto'>
          <DialogHeader>
            <DialogTitle>„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥Ë°®Á§∫</DialogTitle>
          </DialogHeader>
          <div className='p-0 overflow-auto'>
            {currentTemplate ? (
              <MarkdownViewer
                template={currentTemplate}
                onApplyMarkdownTemplate={handleApplyMarkdownTemplate}
              />
            ) : (
              <div className='p-4 text-red-500'>
                „ÉÜ„É≥„Éó„É¨„Éº„Éà„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Éá„Ç∂„Ç§„Éä„Éº„ÅßË¶ÅÁ¥†„ÇíËøΩÂä†„Åó„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>

      {/* ReactCodeEditor„ÉÄ„Ç§„Ç¢„É≠„Ç∞ */}
      <ReactCodeEditor
        open={isReactEditorOpen}
        onOpenChange={setIsReactEditorOpen}
        onGenerateSvg={handleReactSvgGenerate}
      />
    </div>
  );
}

export default PDFDesignerApp;
